<!DOCTYPE html>
<title>Hat</title>

<style>
    body {
        margin: 0;
    }

    svg {
        transform: scaleY(-1);
    }

    polygon {
        fill: #9999ff;
        stroke-width: 0.1;
    }

    #stage {
        position: relative;
    }

    #svg-wrapper,
    #toolbar {
        position: absolute;
    }

    #main-svg {
        overflow: hidden;
        display: block;
    }

    #toolbar {
        padding: 0.5em;
        color: white;
        background-color: #0007;
    }
</style>

<div id="app">
    <div id="stage">
        <div id="svg-wrapper">
            <svg id="main-svg" :view-box.camel="svgViewBox" :width="width" :height="height"
                @pointerdown="pointerDownHandler" @pointermove="pointerMoveHandler" @pointerup="pointerUpHandler"
                @wheel="wheelHandler">
                <!-- <g v-for="(hat, i) in hats">
                <polygon :points="getPolylinePoints(hat)" fill="white" :stroke="hat.selected ? 'black' : 'gray'"
                    @pointerdown="hatSelect($event, hat, i)" @dblclick="hatReflect($event, hat)" />
            </g> -->
                <g v-for="(hat, i) in hats2">
                    <polygon :points="getPolylinePoints2(hat).svgPoints" fill="white" stroke="black" />
                </g>
                <g v-for="(hat, i) in hats2">
                    <g v-for="node in getPolylinePoints2(hat).nodes">
                        <circle :cx="node.ev.x" :cy="node.ev.y" r="0.1" @mouseover="coord = node.v" />
                    </g>
                </g>
            </svg>
        </div>
        <div id="toolbar">
            <label>
                <input type="range" min="0" max="1" step="0.001" v-model.number="a">
                a {{a}}
            </label><br>
            Scale: {{ scale }}<br>
            Node: {{coord}}
        </div>
    </div>
</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
    const { createApp } = Vue

    class Affine {
        constructor(a, b, c, d, e, f) {
            // Affine matrix
            // a, b, c
            // d, e, f
            // 0, 0, 1
            this.a = a;
            this.b = b;
            this.c = { a: c.a, b: c.b };
            this.d = d;
            this.e = e;
            this.f = { a: f.a, b: f.b };
        }

        static identity() {
            return new Affine(1, 0, { a: 0, b: 0 }, 0, 1, { a: 0, b: 0 });
        }

        mul(m) {
            return new Affine(
                m.a * this.a + m.b * this.d,
                m.a * this.b + m.b * this.e,
                { a: m.a * this.c.a + m.b * this.f.a + m.c.a, b: m.a * this.c.b + m.b * this.f.b + m.c.b },
                m.d * this.a + m.e * this.d,
                m.d * this.b + m.e * this.e,
                { a: m.d * this.c.a + m.e * this.f.a + m.f.a, b: m.d * this.c.b + m.e * this.f.b + m.f.b },
            );
        }

        static mul(m, n) {
            return new Affine(
                m.a * n.a + m.b * n.d,
                m.a * n.b + m.b * n.e,
                { a: m.a * n.c.a + m.b * n.f.a + m.c.a, b: m.a * n.c.b + m.b * n.f.b + m.c.b },
                m.d * n.a + m.e * n.d,
                m.d * n.b + m.e * n.e,
                { a: m.d * n.c.a + m.e * n.f.a + m.f.a, b: m.d * n.c.b + m.e * n.f.b + m.f.b },
            );
        }

        mulVec(v) {
            return {
                x: {
                    a: this.a * v.x.a + this.b * v.y.a + this.c.a,
                    b: this.a * v.x.b + this.b * v.y.b + this.c.b,
                },
                y: {
                    a: this.d * v.x.a + this.e * v.y.a + this.f.a,
                    b: this.d * v.x.b + this.e * v.y.b + this.f.b,
                },
            };
        }

        transition(x, y) {
            return new Affine(this.a, this.b, { a: this.c.a + x.a, b: this.c.b + x.b }, this.d, this.e, { a: this.f.a + y.a, b: this.f.b + y.b });
        }

        static transition(x, y) {
            return new Affine(1, 0, { a: x.a, b: x.b }, 0, 1, { a: y.a, b: y.b });
        }

        static transitionRot(x, y, i) {
            return this.transition(x, y).mul(this.rotation(i));
        }

        static rotTransition(i, x, y) {
            return this.rotation(i).mul(this.transition(x, y));
        }

        static transitionAdd(x1, y1, x2, y2) {
            return new Affine(1, 0, { a: x1.a + x2.a, b: x1.b + x2.b }, 0, 1, { a: y1.a + y2.a, b: y1.b + y2.b });
        }

        // flip() {
        //     const a = this.a;
        //     const b = this.b;
        //     const c = this.c;
        //     const d = this.d;
        //     const e = this.e;
        //     const f = this.f;
        //     return new Affine(a + d, b + e, { a: c.a + f.a, b: c.b + f.b }, -d, -e, { a: -f.a, b: -f.b });
        // }

        static flip() {
            // flip matrix [1, 1, 0, -1]
            return this.rotation(3).mul(new Affine(1, 1, { a: 0, b: 0 }, 0, -1, { a: 0, b: 0 }));
        }

        static rotation60() {
            return new Affine(0, -1, { a: 0, b: 0 }, 1, 1, { a: 0, b: 0 });
        }

        static rotation(i) {
            i = (i % 6 + 6) % 6;
            if (i == 0) {
                return this.identity();
            } else {
                return this.rotation(i - 1).mul(this.rotation60());
            }
        }
    }

    // const hat = [
    //     [0, -1],
    //     [1, -1],
    //     [1, 0],
    //     [0, 1],
    //     [1, 2],
    //     [2, 1],
    //     [3, -1],
    //     [4, -1],
    // ];

    const rotM = [
        [1, 0, 0, 1],
        [0, -1, 1, 1],
        [-1, -1, 1, 0],
        [-1, 0, 0, -1],
        [0, 1, -1, -1],
        [1, 1, -1, 0],
    ];

    const hatOutline = [
        [-1, 0],
        [-2, -1],
        [-1, -2],
        [1, -2],
        [1, -1],
        [3, -2],
        [4, -1],
        [3, 0],
        [2, 0],
        [1, 2],
        [-1, 3],
        [-1, 2],
        [-2, 2],
    ];

    const hatOutlines = [];
    // Non-reflected hats
    for (let i = 0; i < 6; i++) {
        let rotOutline = [];
        for (p of hatOutline) {
            const x = rotM[i][0] * p[0] + rotM[i][1] * p[1];
            const y = rotM[i][2] * p[0] + rotM[i][3] * p[1];
            rotOutline.push([x, y]);
        }
        hatOutlines.push(rotOutline);
    }
    // X-axis reflected hats
    for (let i = 0; i < 6; i++) {
        let rotOutline = [];
        for (p of hatOutline) {
            const xx = p[0] + p[1];
            const yy = - p[1];
            const x = rotM[i][0] * xx + rotM[i][1] * yy;
            const y = rotM[i][2] * xx + rotM[i][3] * yy;
            rotOutline.push([x, y]);
        }
        hatOutlines.push(rotOutline);
    }

    const deg60 = Math.PI / 3;
    const cos60 = Math.cos(deg60);
    const sin60 = Math.sin(deg60);

    createApp({
        data() {
            return {
                width: window.innerWidth,
                height: window.innerHeight,
                cx: 0,
                cy: 0,
                scale: 32,
                a: 0.5,
                coord: null,
                hats: [],
                hats2: [],
                selected: [],
                moveHandler: null,
                hatHeld: false,
                svg: null,
            }
        },
        computed: {
            svgViewBox() {
                const x = this.cx - this.width / 2 / this.scale;
                const y = this.cy - this.height / 2 / this.scale;
                const w = this.width / this.scale;
                const h = this.height / this.scale;
                return `${x} ${y} ${w} ${h}`
            }
        },
        methods: {
            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
            },
            clearSelected() {
                for (hat of this.selected) {
                    hat.selected = false;
                }
                this.selected = [];
            },
            getPolylinePoints(hat) {
                let res = "";
                const r = ((hat.r % 6) + 6) % 6;
                for (let p of hatOutlines[hat.reflected ? 6 + r : r]) {
                    const x = hat.x + p[0];
                    const y = hat.y + p[1];

                    const xx = x + y * cos60;
                    const yy = y * sin60;

                    res += `${xx} ${yy} `
                }
                return res;
            },
            getPolylinePoints2(hat) {
                const [a, b] = [this.a, 1 - this.a];

                const hatOutline2 = [
                    { x: { a: 0, b: 0 }, y: { a: 0, b: 0 } },
                    { x: { a: 0, b: -1 }, y: { a: 0, b: -1 } },
                    { x: { a: 1, b: -1 }, y: { a: -1, b: -1 } },
                    { x: { a: 3, b: -1 }, y: { a: -1, b: -1 } },
                    { x: { a: 3, b: -1 }, y: { a: 0, b: -1 } },
                    { x: { a: 3, b: 1 }, y: { a: 0, b: -2 } },
                    { x: { a: 3, b: 2 }, y: { a: 0, b: -1 } },
                    { x: { a: 2, b: 2 }, y: { a: 1, b: -1 } },
                    { x: { a: 1, b: 2 }, y: { a: 1, b: -1 } },
                    { x: { a: 1, b: 1 }, y: { a: 1, b: 1 } },
                    { x: { a: 1, b: -1 }, y: { a: 1, b: 2 } },
                    { x: { a: 1, b: -1 }, y: { a: 0, b: 2 } },
                    { x: { a: 0, b: -1 }, y: { a: 0, b: 2 } },
                ];

                const af = hat.affine;

                let res = "";
                let nodes = [];
                for (let p of hatOutline2) {
                    const v = af.mulVec(p);

                    const x = a * v.x.a + b * v.x.b;
                    const y = a * v.y.a + b * v.y.b;

                    const xx = x + y * cos60;
                    const yy = y * sin60;

                    res += `${xx} ${yy} `
                    nodes.push({ v: v, ev: { x: xx, y: yy } });
                }
                return { svgPoints: res, nodes: nodes };
            },
            getMousePosition(e) {
                const rect = this.svg.getBoundingClientRect()
                const x = e.clientX - rect.left;
                const y = this.height - e.clientY - rect.top;
                return [x, y];
            },
            pointerDownHandler(e) {
                const [x0, y0] = this.getMousePosition(e);
                const [cx0, cy0] = [this.cx, this.cy];
                const handler = (e_) => {
                    const [x, y] = this.getMousePosition(e_);
                    const dx = (x - x0) / this.scale;
                    const dy = (y - y0) / this.scale;
                    this.cx = cx0 - dx;
                    this.cy = cy0 - dy;
                }
                this.moveHandler = handler;

                this.clearSelected();
            },
            pointerMoveHandler(e) {
                if (this.moveHandler !== null) {
                    this.moveHandler(e);
                }
            },
            pointerUpHandler() {
                this.hatHeld = false;
                this.moveHandler = null;
            },
            calcCog() {
                let cogX = 0;
                let cogY = 0;
                for (hat of this.selected) {
                    cogX += hat.x;
                    cogY += hat.y;
                }
                cogX = Math.round(cogX / this.selected.length);
                cogY = Math.round(cogY / this.selected.length);
                return [cogX, cogY];
            },
            wheelHandler(e) {
                e.stopPropagation();
                e.preventDefault();

                if (this.hatHeld) {
                    // Hat rotation

                    const [cogX, cogY] = this.calcCog();

                    // Rotate around the cog
                    for (hat of this.selected) {
                        const dx = hat.dx;
                        const dy = hat.dy;
                        if (e.deltaY > 0) {
                            // -60 deg rotation
                            hat.dx = 1 * dx + 1 * dy;
                            hat.dy = -1 * dx + 0 * dy;
                            hat.r = (hat.r - 1 + 6) % 6;
                        } else {
                            // 60 deg rotation
                            hat.dx = 0 * dx - 1 * dy;
                            hat.dy = 1 * dx + 1 * dy;
                            hat.r = (hat.r + 1 + 6) % 6;
                        }
                        hat.x = cogX + hat.dx;
                        hat.y = cogY + hat.dy;
                    }
                } else {
                    // Zoom in/out
                    const [x, y] = this.getMousePosition(e);
                    const dx = (x - this.width / 2) / this.scale;
                    const dy = (y - this.height / 2) / this.scale;

                    const scaleFactor = 1.2;

                    if (e.deltaY > 0) {
                        this.cx = this.cx - dx * (scaleFactor - 1);
                        this.cy = this.cy - dy * (scaleFactor - 1);
                        this.scale /= scaleFactor;
                    } else {
                        this.cx = this.cx + dx * (1 - 1 / scaleFactor);
                        this.cy = this.cy + dy * (1 - 1 / scaleFactor);
                        this.scale *= scaleFactor;
                    }
                }
            },
            hatSelect(e, hat, i) {
                e.stopPropagation();

                if (!hat.selected && !e.ctrlKey) {
                    this.clearSelected();
                }

                this.hatHeld = true;
                if (!hat.selected) {
                    this.selected.push(hat);
                    hat.selected = true;
                }

                // Newly clicked hat is always front
                // swap elements
                const length = this.hats.length;
                if (length > 1) {
                    const tmp = this.hats[length - 1];
                    this.hats[length - 1] = this.hats[i];
                    this.hats[i] = tmp;
                }

                const [x0, y0] = this.getMousePosition(e);
                const [cogX, cogY] = this.calcCog();
                for (hat of this.selected) {
                    hat.dx = hat.x - cogX;
                    hat.dy = hat.y - cogY;
                }
                const [hx0, hy0] = [hat.x, hat.y];
                const handler = (e_) => {
                    const [x, y] = this.getMousePosition(e_);
                    const dx = (x - x0) / this.scale;
                    const dy = (y - y0) / this.scale;

                    // const a = 1;
                    const b = -1 / Math.sqrt(3);
                    // const c = 0;
                    const d = 2 / Math.sqrt(3);

                    const dxx = Math.round(dx + b * dy);
                    const dyy = Math.round(d * dy);

                    for (hat of this.selected) {
                        hat.x = cogX + hat.dx + dxx;
                        hat.y = cogY + hat.dy + dyy;
                    }
                }
                this.moveHandler = handler;
            },
            hatReflect(e, hat) {
                hat.reflected = !hat.reflected;
            },
            hoge() {
                let hats = [];
                const h7 = (depth, affine) => {
                    if (depth == 0) {
                        hats.push({ affine: affine });
                    }
                    if (depth == 1) {
                        h7(depth - 1, Affine.mul(affine, Affine.rotation(-2)));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(-3, { a: 0, b: -2 }, { a: 0, b: 4 })));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(2, { a: 2, b: 0 }, { a: -1, b: 3 })));
                        h7(depth - 1, Affine.mul(affine, Affine.mul(Affine.rotTransition(-1, { a: 3, b: 1 }, { a: -3, b: 1 }), Affine.flip())));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(-2, { a: 3, b: 3 }, { a: 0, b: 0 })));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(-1, { a: 1, b: 1 }, { a: -2, b: -2 })));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(0, { a: 3, b: 3 }, { a: -3, b: -3 })));
                    }
                }
                const h8 = (depth, affine) => {
                    if (depth == 0) {
                        hats.push({ affine: affine });
                    }
                    if (depth == 1) {
                        h7(depth - 1, Affine.mul(affine, Affine.rotation(-2)));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(-3, { a: 0, b: -2 }, { a: 0, b: 4 })));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(2, { a: 2, b: 0 }, { a: -1, b: 3 })));
                        h7(depth - 1, Affine.mul(affine, Affine.mul(Affine.rotTransition(-1, { a: 3, b: 1 }, { a: -3, b: 1 }), Affine.flip())));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(-2, { a: 3, b: 3 }, { a: 0, b: 0 })));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(-1, { a: 1, b: 1 }, { a: -2, b: -2 })));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(0, { a: 3, b: 3 }, { a: -3, b: -3 })));
                        h7(depth - 1, Affine.mul(affine, Affine.rotTransition(-2, { a: -1, b: -3 }, { a: -1, b: 3 })));
                    }
                }
                h8(1, Affine.identity());
                return hats;
            },
        },
        mounted() {
            this.resize();
            window.addEventListener('resize', this.resize);

            this.svg = document.getElementById('main-svg');

            // this.hats2.push({ affine: Affine.identity() });
            // this.hats2.push({ affine: Affine.transitionRot({ a: -2, b: 0 }, { a: 1, b: 3 }, 0) });
            // this.hats2.push({ affine: Affine.flip().mul(Affine.rotTransition(3, { a: -1, b: -3 }, { a: 2, b: 6 })) });
            // this.hats2.push({ affine: Affine.flip().transition({ a: -1, b: -3 }, { a: 2, b: 6 }) });

            this.hats2 = this.hoge();
        },
    }).mount('#app')
</script>