<!DOCTYPE html>
<title>Hat</title>

<style>
    body {
        margin: 0;
    }

    svg {
        transform: scaleY(-1);
    }

    polygon {
        stroke-width: 0.1;
    }

    #stage {
        position: relative;
    }

    #svg-wrapper,
    #toolbar {
        position: absolute;
    }

    #main-svg {
        overflow: hidden;
        display: block;
    }

    #toolbar {
        padding: 0.5em;
        color: white;
        background-color: #0007;
    }
</style>

<div id="app">
    <div id="stage">
        <div id="svg-wrapper">
            <svg id="main-svg" :view-box.camel="svgViewBox" :width="width" :height="height"
                @pointerdown="pointerDownHandler" @pointermove="pointerMoveHandler" @pointerup="pointerUpHandler"
                @wheel="wheelHandler">
                <g v-if="mode == 'free'">
                    <polygon v-for="(hat, i) in hats" :points="getPolylinePoints2(hat).svgPoints" fill="white"
                        :stroke="hat.selected ? 'black' : 'gray'" @pointerdown="hatSelect($event, hat, i)"
                        @dblclick="hatReflect($event, hat)" />
                </g>
                <g v-if="mode == 'substitution'">
                    <polygon v-for="(hat, i) in hats2" :points="getPolylinePoints2(hat).svgPoints" :fill="hat.color"
                        stroke="black" />
                    <g v-if="options.showNodes">
                        <g v-for="(hat, i) in hats2">
                            <g v-for="node in getPolylinePoints2(hat).nodes">
                                <circle :cx="node.ev.x" :cy="node.ev.y" r="0.1" @mouseover="coord = node.v" />
                            </g>
                        </g>
                    </g>
                </g>
            </svg>
        </div>
        <div id="toolbar">
            <label>
                <input type="range" min="0" max="1" step="0.001" v-model.number="a">
                a {{a}}
            </label><br>
            Scale: {{ scale }}<br>
            <label>
                <input type="checkbox" v-model="options.showNodes">
                Show nodes
                <br>
            </label>
            <label>
                <input type="radio" value="substitution" v-model="mode" />
                substitution
            </label>
            <label>
                <input type="radio" value="free" v-model="mode" />
                free
            </label>
            <div v-if="options.showNodes">
                Node: {{coord}}
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script src="affine.js"></script>
<script>
    const { createApp } = Vue

    const hatOutline2 = [
        { x: { a: 0, b: 0 }, y: { a: 0, b: 0 } },
        { x: { a: 0, b: -1 }, y: { a: 0, b: -1 } },
        { x: { a: 1, b: -1 }, y: { a: -1, b: -1 } },
        { x: { a: 2, b: -1 }, y: { a: -1, b: -1 } },
        { x: { a: 3, b: -1 }, y: { a: -1, b: -1 } },
        { x: { a: 3, b: -1 }, y: { a: 0, b: -1 } },
        { x: { a: 3, b: 1 }, y: { a: 0, b: -2 } },
        { x: { a: 3, b: 2 }, y: { a: 0, b: -1 } },
        { x: { a: 2, b: 2 }, y: { a: 1, b: -1 } },
        { x: { a: 1, b: 2 }, y: { a: 1, b: -1 } },
        { x: { a: 1, b: 1 }, y: { a: 1, b: 1 } },
        { x: { a: 1, b: -1 }, y: { a: 1, b: 2 } },
        { x: { a: 1, b: -1 }, y: { a: 0, b: 2 } },
        { x: { a: 0, b: -1 }, y: { a: 0, b: 2 } },
    ];

    const deg60 = Math.PI / 3;
    const cos60 = Math.cos(deg60);
    const sin60 = Math.sin(deg60);

    createApp({
        data() {
            return {
                width: window.innerWidth,
                height: window.innerHeight,
                cx: 0,
                cy: 0,
                scale: 16,
                mode: 'free',
                a: 0.5,
                coord: null,
                hats: [],
                hats2: [],
                selected: [],
                moveHandler: null,
                hatHeld: false,
                svg: null,
                options: {
                    showNodes: false,
                }
            }
        },
        computed: {
            svgViewBox() {
                const x = this.cx - this.width / 2 / this.scale;
                const y = this.cy - this.height / 2 / this.scale;
                const w = this.width / this.scale;
                const h = this.height / this.scale;
                return `${x} ${y} ${w} ${h}`
            }
        },
        methods: {
            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
            },
            clearSelected() {
                for (hat of this.selected) {
                    hat.selected = false;
                }
                this.selected = [];
            },
            getOutline(affine) {
                const outline = [];
                for (let p of hatOutline2) {
                    const v = affine.mulVec(p);
                    outline.push(v);
                }
                return outline;
            },
            getPolylinePoints2(hat) {
                const [a, b] = [this.a, 1 - this.a];

                if (!hat.outline) {
                    hat.outline = this.getOutline(hat.affine);
                }

                let res = "";
                let nodes = [];
                for (let p of hat.outline) {
                    const x = a * p.x.a + b * p.x.b;
                    const y = a * p.y.a + b * p.y.b;

                    const xx = x + y * cos60;
                    const yy = y * sin60;

                    res += `${xx} ${yy} `
                    nodes.push({ v: p, ev: { x: xx, y: yy } });
                }
                return { svgPoints: res, nodes: nodes };
            },
            getMousePosition(e) {
                const rect = this.svg.getBoundingClientRect()
                const x = e.clientX - rect.left;
                const y = this.height - e.clientY - rect.top;
                return [x, y];
            },
            pointerDownHandler(e) {
                const [x0, y0] = this.getMousePosition(e);
                const [cx0, cy0] = [this.cx, this.cy];
                const handler = (e_) => {
                    const [x, y] = this.getMousePosition(e_);
                    const dx = (x - x0) / this.scale;
                    const dy = (y - y0) / this.scale;
                    this.cx = cx0 - dx;
                    this.cy = cy0 - dy;
                }
                this.moveHandler = handler;

                this.clearSelected();
            },
            pointerMoveHandler(e) {
                if (this.moveHandler !== null) {
                    this.moveHandler(e);
                }
            },
            pointerUpHandler() {
                this.hatHeld = false;
                this.moveHandler = null;
            },
            calcCog() {
                let cogX = 0;
                let cogY = 0;
                for (hat of this.selected) {
                    const p = hat.affine.mulVec({ x: { a: 0, b: 0 }, y: { a: 0, b: 0 } });
                    cogX += p.x.a;
                    cogY += p.y.a;
                }
                cogX = Math.round(cogX / this.selected.length);
                cogY = Math.round(cogY / this.selected.length);
                return [cogX, cogY];
            },
            wheelHandler(e) {
                e.stopPropagation();
                e.preventDefault();

                if (this.hatHeld) {
                    // Hat rotation
                    const [cogX, cogY] = this.calcCog();
                    // Rotate around the cog
                    const rot = e.deltaY > 0 ? -1 : 1;
                    const affine = Affine.mul(
                        Affine.mul(Affine.transition({ a: cogX, b: 0 }, { a: cogY, b: 0 }),
                            Affine.rotation(rot)),
                        Affine.transition({ a: -cogX, b: 0 }, { a: -cogY, b: 0 }),
                    );
                    for (hat of this.selected) {
                        hat.affine = Affine.mul(affine, hat.affine);
                        hat.outline = null;
                    }
                } else {
                    // Zoom in/out
                    const [x, y] = this.getMousePosition(e);
                    const dx = (x - this.width / 2) / this.scale;
                    const dy = (y - this.height / 2) / this.scale;

                    const scaleFactor = 1.2;

                    if (e.deltaY > 0) {
                        this.cx = this.cx - dx * (scaleFactor - 1);
                        this.cy = this.cy - dy * (scaleFactor - 1);
                        this.scale /= scaleFactor;
                    } else {
                        this.cx = this.cx + dx * (1 - 1 / scaleFactor);
                        this.cy = this.cy + dy * (1 - 1 / scaleFactor);
                        this.scale *= scaleFactor;
                    }
                }
            },
            hatSelect(e, hat, i) {
                e.stopPropagation();

                if (!hat.selected && !e.ctrlKey) {
                    this.clearSelected();
                }

                this.hatHeld = true;
                if (!hat.selected) {
                    this.selected.push(hat);
                    hat.selected = true;
                }

                // Newly clicked hat is always front
                // swap elements
                const length = this.hats.length;
                if (length > 1) {
                    const tmp = this.hats[length - 1];
                    this.hats[length - 1] = this.hats[i];
                    this.hats[i] = tmp;
                }

                const [x0, y0] = this.getMousePosition(e);
                const [cogX, cogY] = this.calcCog();
                for (hat of this.selected) {
                    hat.dx = hat.x - cogX;
                    hat.dy = hat.y - cogY;
                    hat.orgAffine = hat.affine;
                }
                const [hx0, hy0] = [hat.x, hat.y];
                const handler = (e_) => {
                    const [x, y] = this.getMousePosition(e_);
                    const dx = (x - x0) / this.scale;
                    const dy = (y - y0) / this.scale;

                    // const a = 1;
                    const b = -1 / Math.sqrt(3);
                    // const c = 0;
                    const d = 2 / Math.sqrt(3);

                    // TODO: Why is 2* needed?
                    const dxx = Math.round(2 * (dx + b * dy));
                    const dyy = Math.round(2 * (d * dy));

                    for (hat of this.selected) {
                        hat.affine = Affine.mul(Affine.transition({ a: dxx, b: 0 }, { a: dyy, b: 0 }), hat.orgAffine);
                        hat.outline = null;
                        hat.x = cogX + hat.dx + dxx;
                        hat.y = cogY + hat.dy + dyy;
                    }
                }
                this.moveHandler = handler;
            },
            hatReflect(e, hat) {
                hat.affine = Affine.mul(hat.affine, Affine.flip());
                hat.outline = null;
            },
            hoge() {
                let hats = [];
                const construct = (type, depth) => {
                    if (depth == 0) {
                        const h = hatOutline2;
                        const quad = [h[2], h[6], h[8], h[10]];
                        return { type: type, depth: 0, quad: quad, affine: Affine.identity() };
                    } else {
                        const clusters = [];
                        const rules = [
                            // type, rot degree, prev quad idx connects to, current quad idx connects to prev
                            [0, [3, 0]],
                            [1, [2, 0]],
                            [2, [2, 0]],
                            [0, [3, 3]],
                            [4, [0, 0]],
                            [5, [2, 0]],
                            [0, [2, 0]],
                        ]
                        for (let i = 0; i < 7; i++) {
                            const r = rules[i];
                            const cluster = construct(i, depth - 1);
                            clusters.push(cluster);
                            if (i > 0) {
                                const from = clusters[i - 1].quad[r[1][0]];
                                const rotAffine = Affine.rotation(r[0]);
                                const to = rotAffine.mulVec(clusters[i].quad[r[1][1]]);
                                const transAffine = Affine.transition({ a: -to.x.a, b: -to.x.b }, { a: -to.y.a, b: -to.y.b });
                                const affine = Affine.mul(Affine.transition(from.x, from.y), Affine.mul(transAffine, rotAffine));
                                for (let j = 0; j < 4; j++) {
                                    clusters[i].quad[j] = affine.mulVec(clusters[i].quad[j]);
                                }
                                clusters[i].affine = Affine.mul(affine, clusters[i].affine);
                            }
                        }
                        const nextQuad = [[4, 1], [6, 2], [1, 1], [2, 2]];
                        const quad = [];
                        for (let nq of nextQuad) {
                            quad.push(clusters[nq[0]].quad[nq[1]]);
                        }
                        return { type: type, clusters: clusters, quad: quad, depth: depth, affine: Affine.identity() };
                    }
                };
                const traverse = (cluster, affine) => {
                    if (cluster.depth == 0) {
                        hats.push({ affine: affine, color: 'white', outline: this.getOutline(affine) });
                        if (cluster.type == 3) {
                            af = Affine.mul(affine, Affine.mul(Affine.rotTransition(1, { a: 3, b: 1 }, { a: 0, b: -2 }), Affine.flip()));
                            hats.push({ affine: af, color: 'DodgerBlue', outline: this.getOutline(af) });
                        }
                    } else {
                        const n = cluster.type == 3 ? 6 : 7;
                        for (let i = 0; i < n; i++) {
                            const c = cluster.clusters[i];
                            traverse(c, Affine.mul(affine, c.affine));
                        }
                    }
                };
                traverse(construct(0, 3), Affine.rotation(-2));
                return hats;
            },
        },
        mounted() {
            this.resize();
            window.addEventListener('resize', this.resize);

            this.svg = document.getElementById('main-svg');
            this.hats2 = this.hoge();
            this.hats = [
                { affine: Affine.identity() },
                { affine: Affine.flip() },
            ];
        },
    }).mount('#app')
</script>