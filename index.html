<!DOCTYPE html>
<title>Hat</title>

<style>
    body {
        margin: 0;
    }

    svg {
        transform: scaleY(-1);
    }

    polygon {
        fill: #9999ff;
        stroke-width: 0.1;
    }

    .svg-wrapper {
        overflow: hidden;
    }
</style>

<div id="app">
    <div class="svg-wrapper">
        <svg id="main-svg" :view-box.camel="svgViewBox" :width="width" :height="height"
            @pointerdown="pointerDownHandler" @pointermove="pointerMoveHandler" @pointerup="pointerUpHandler"
            @wheel="wheelHandler">
            <g v-for="(hat, i) in hats">
                <polygon :points="getPolylinePoints(hat)" fill="white" :stroke="hat.selected ? 'black' : 'gray'"
                    @pointerdown="hatSelect($event, hat, i)" @dblclick="hatReflect($event, hat)" />
            </g>
        </svg>
    </div>
    <div>
        Scale: {{ scale }}
    </div>
</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
    const { createApp } = Vue

    // const hat = [
    //     [0, -1],
    //     [1, -1],
    //     [1, 0],
    //     [0, 1],
    //     [1, 2],
    //     [2, 1],
    //     [3, -1],
    //     [4, -1],
    // ];

    const rotM = [
        [1, 0, 0, 1],
        [0, -1, 1, 1],
        [-1, -1, 1, 0],
        [-1, 0, 0, -1],
        [0, 1, -1, -1],
        [1, 1, -1, 0],
    ];

    const hatOutline = [
        [-1, 0],
        [-2, -1],
        [-1, -2],
        [1, -2],
        [1, -1],
        [3, -2],
        [4, -1],
        [3, 0],
        [2, 0],
        [1, 2],
        [-1, 3],
        [-1, 2],
        [-2, 2],
    ];

    const hatOutlines = [];
    // Non-reflected hats
    for (let i = 0; i < 6; i++) {
        let rotOutline = [];
        for (p of hatOutline) {
            const x = rotM[i][0] * p[0] + rotM[i][1] * p[1];
            const y = rotM[i][2] * p[0] + rotM[i][3] * p[1];
            rotOutline.push([x, y]);
        }
        hatOutlines.push(rotOutline);
    }
    // X-axis reflected hats
    for (let i = 0; i < 6; i++) {
        let rotOutline = [];
        for (p of hatOutline) {
            const xx = p[0] + p[1];
            const yy = - p[1];
            const x = rotM[i][0] * xx + rotM[i][1] * yy;
            const y = rotM[i][2] * xx + rotM[i][3] * yy;
            rotOutline.push([x, y]);
        }
        hatOutlines.push(rotOutline);
    }

    const deg60 = Math.PI / 3;
    const cos60 = Math.cos(deg60);
    const sin60 = Math.sin(deg60);

    createApp({
        data() {
            return {
                width: window.innerWidth,
                height: window.innerHeight,
                cx: 0,
                cy: 0,
                scale: 8,
                hats: [],
                selected: [],
                moveHandler: null,
                hatHeld: false,
                svg: null,
            }
        },
        computed: {
            svgViewBox() {
                const x = this.cx - this.width / 2 / this.scale;
                const y = this.cy - this.height / 2 / this.scale;
                const w = this.width / this.scale;
                const h = this.height / this.scale;
                return `${x} ${y} ${w} ${h}`
            }
        },
        methods: {
            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
            },
            clearSelected() {
                for (hat of this.selected) {
                    hat.selected = false;
                }
                this.selected = [];
            },
            getPolylinePoints(hat) {
                let res = "";
                const r = ((hat.r % 6) + 6) % 6;
                for (let p of hatOutlines[hat.reflected ? 6 + r : r]) {
                    const x = hat.x + p[0];
                    const y = hat.y + p[1];

                    const xx = x + y * cos60;
                    const yy = y * sin60;

                    res += `${xx} ${yy} `
                }
                return res;
            },
            getMousePosition(e) {
                const rect = this.svg.getBoundingClientRect()
                const x = e.clientX - rect.left;
                const y = this.height - e.clientY - rect.top;
                return [x, y];
            },
            pointerDownHandler(e) {
                const [x0, y0] = this.getMousePosition(e);
                const [cx0, cy0] = [this.cx, this.cy];
                const handler = (e_) => {
                    const [x, y] = this.getMousePosition(e_);
                    const dx = (x - x0) / this.scale;
                    const dy = (y - y0) / this.scale;
                    this.cx = cx0 - dx;
                    this.cy = cy0 - dy;
                }
                this.moveHandler = handler;

                this.clearSelected();
            },
            pointerMoveHandler(e) {
                if (this.moveHandler !== null) {
                    this.moveHandler(e);
                }
            },
            pointerUpHandler() {
                this.hatHeld = false;
                this.moveHandler = null;
            },
            calcCog() {
                let cogX = 0;
                let cogY = 0;
                for (hat of this.selected) {
                    cogX += hat.x;
                    cogY += hat.y;
                }
                cogX = Math.round(cogX / this.selected.length);
                cogY = Math.round(cogY / this.selected.length);
                return [cogX, cogY];
            },
            wheelHandler(e) {
                e.stopPropagation();
                e.preventDefault();

                if (this.hatHeld) {
                    // Hat rotation

                    const [cogX, cogY] = this.calcCog();

                    // Rotate around the cog
                    for (hat of this.selected) {
                        const dx = hat.dx;
                        const dy = hat.dy;
                        if (e.deltaY > 0) {
                            // -60 deg rotation
                            hat.dx = 1 * dx + 1 * dy;
                            hat.dy = -1 * dx + 0 * dy;
                            hat.r = (hat.r - 1 + 6) % 6;
                        } else {
                            // 60 deg rotation
                            hat.dx = 0 * dx - 1 * dy;
                            hat.dy = 1 * dx + 1 * dy;
                            hat.r = (hat.r + 1 + 6) % 6;
                        }
                        hat.x = cogX + hat.dx;
                        hat.y = cogY + hat.dy;
                    }
                } else {
                    // Zoom in/out
                    const [x, y] = this.getMousePosition(e);
                    const dx = (x - this.width / 2) / this.scale;
                    const dy = (y - this.height / 2) / this.scale;

                    const scaleFactor = 1.2;

                    if (e.deltaY > 0) {
                        this.cx = this.cx - dx * (scaleFactor - 1);
                        this.cy = this.cy - dy * (scaleFactor - 1);
                        this.scale /= scaleFactor;
                    } else {
                        this.cx = this.cx + dx * (1 - 1 / scaleFactor);
                        this.cy = this.cy + dy * (1 - 1 / scaleFactor);
                        this.scale *= scaleFactor;
                    }
                }
            },
            hatSelect(e, hat, i) {
                e.stopPropagation();

                if (!hat.selected && !e.ctrlKey) {
                    this.clearSelected();
                }

                this.hatHeld = true;
                if (!hat.selected) {
                    this.selected.push(hat);
                    hat.selected = true;
                }

                // Newly clicked hat is always front
                // swap elements
                const length = this.hats.length;
                if (length > 1) {
                    const tmp = this.hats[length - 1];
                    this.hats[length - 1] = this.hats[i];
                    this.hats[i] = tmp;
                }

                const [x0, y0] = this.getMousePosition(e);
                const [cogX, cogY] = this.calcCog();
                for (hat of this.selected) {
                    hat.dx = hat.x - cogX;
                    hat.dy = hat.y - cogY;
                }
                const [hx0, hy0] = [hat.x, hat.y];
                const handler = (e_) => {
                    const [x, y] = this.getMousePosition(e_);
                    const dx = (x - x0) / this.scale;
                    const dy = (y - y0) / this.scale;

                    // const a = 1;
                    const b = -1 / Math.sqrt(3);
                    // const c = 0;
                    const d = 2 / Math.sqrt(3);

                    const dxx = Math.round(dx + b * dy);
                    const dyy = Math.round(d * dy);

                    for (hat of this.selected) {
                        hat.x = cogX + hat.dx + dxx;
                        hat.y = cogY + hat.dy + dyy;
                    }
                }
                this.moveHandler = handler;
            },
            hatReflect(e, hat) {
                hat.reflected = !hat.reflected;
            },
        },
        mounted() {
            this.resize();
            window.addEventListener('resize', this.resize);

            this.svg = document.getElementById('main-svg');

            // const n = 16;
            // for (let i = 0; i < n; i++) {
            //     for (let j = 0; j < n; j++) {
            //         this.hats.push({ x: i * 5, y: j * 5, r: (i + j) % 6, selected: false });
            //     }
            // }
            this.hats.push({ x: 0, y: 0, r: 0, selected: false, reflected: false });
            this.hats.push({ x: 10, y: 0, r: 2, selected: false, reflected: false });
            this.hats.push({ x: -10, y: 0, r: 4, selected: false, reflected: false });
        },
    }).mount('#app')
</script>